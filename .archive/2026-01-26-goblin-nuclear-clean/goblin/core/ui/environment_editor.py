"""
Environment Variables Editor (v1.2.18)

Edit .env file and environment variables from TUI.
Secure input for API keys, path validation.
"""

from typing import Dict, List, Optional, Any
from pathlib import Path
import os
from dev.goblin.core.ui.components.box_drawing import render_section, render_separator, BoxStyle


class EnvironmentEditor:
    """
    Panel for editing environment variables.

    Features:
    - View/edit .env file
    - Secure input for GEMINI_API_KEY
    - Path validation
    - Variable validation
    - .env file writing
    """

    def __init__(self):
        """Initialize environment editor"""
        # .env file location
        from dev.goblin.core.utils.paths import PATHS

        self.env_file = PATHS.PROJECT_ROOT / ".env"

        # Load environment variables
        self.env_vars = self._load_env()

        # UI state
        self.selected_index = 0
        self.editing_key = None
        self.edit_buffer = None
        self.modified_keys = set()

    def _load_env(self) -> Dict[str, str]:
        """Load environment variables from .env file"""
        env_vars = {}

        if self.env_file.exists():
            try:
                with open(self.env_file, "r") as f:
                    for line in f:
                        line = line.strip()

                        # Skip comments and empty lines
                        if not line or line.startswith("#"):
                            continue

                        # Parse KEY=VALUE
                        if "=" in line:
                            key, value = line.split("=", 1)
                            key = key.strip()
                            value = value.strip().strip('"').strip("'")
                            env_vars[key] = value
            except Exception:
                pass

        # Add common variables if not present
        if "GEMINI_API_KEY" not in env_vars:
            env_vars["GEMINI_API_KEY"] = ""
        if "UDOS_DATA_DIR" not in env_vars:
            env_vars["UDOS_DATA_DIR"] = ""
        if "UDOS_LOG_LEVEL" not in env_vars:
            env_vars["UDOS_LOG_LEVEL"] = "INFO"

        return env_vars

    def _save_env(self) -> Dict[str, Any]:
        """Save environment variables to .env file"""
        try:
            with open(self.env_file, "w") as f:
                f.write("# uDOS Environment Configuration\n")
                f.write("# Auto-generated by Environment Editor\n\n")

                # Group variables by category
                api_vars = ["GEMINI_API_KEY"]
                path_vars = ["UDOS_DATA_DIR", "UDOS_EXTENSIONS_DIR"]
                system_vars = ["UDOS_LOG_LEVEL", "UDOS_DEBUG"]

                # Write API keys
                f.write("# API Keys\n")
                for key in api_vars:
                    if key in self.env_vars:
                        value = self.env_vars[key]
                        f.write(f'{key}="{value}"\n')
                f.write("\n")

                # Write paths
                f.write("# Paths\n")
                for key in path_vars:
                    if key in self.env_vars:
                        value = self.env_vars[key]
                        f.write(f'{key}="{value}"\n')
                f.write("\n")

                # Write system settings
                f.write("# System Settings\n")
                for key in system_vars:
                    if key in self.env_vars:
                        value = self.env_vars[key]
                        f.write(f'{key}="{value}"\n')
                f.write("\n")

                # Write any other variables
                f.write("# Other Variables\n")
                for key, value in self.env_vars.items():
                    if key not in api_vars + path_vars + system_vars:
                        f.write(f'{key}="{value}"\n')

            return {"success": True}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def render(self) -> str:
        """Render environment editor panel"""
        output = []

        # Header (standardized)
        width = 70
        title = "ENVIRONMENT VARIABLES"
        subtitle = f"{len(self.modified_keys)} modified" if self.modified_keys else None
        header = render_section(
            title, subtitle=subtitle, width=width, style=BoxStyle.SINGLE, align="center"
        )
        output.extend(header.splitlines())
        output.append("")

        # Info
        output.append(f"Editing: {self.env_file}")
        output.append(render_separator(width, style=BoxStyle.SINGLE))
        output.append("")

        # Variables list
        output.extend(self._render_variables())

        # Footer
        output.append("")
        output.append(self._render_footer())

        return "\n".join(output)

    def _render_variables(self) -> List[str]:
        """Render environment variables"""
        output = []

        # Sort keys for consistent display
        sorted_keys = sorted(self.env_vars.keys())

        if not sorted_keys:
            output.append("  (No environment variables)")
            return output

        # Render each variable
        for i, key in enumerate(sorted_keys):
            value = self.env_vars[key]

            # Highlight selected
            prefix = "→ " if i == self.selected_index else "  "

            # Modified indicator
            modified = "*" if key in self.modified_keys else " "

            # Editing indicator
            if self.editing_key == key:
                # Mask sensitive values while editing
                display_buffer = self._mask_value(key, self.edit_buffer)
                output.append(f"{prefix}{modified}{key}: [{display_buffer}]_")
            else:
                display_value = self._format_value(key, value)
                output.append(f"{prefix}{modified}{key}: {display_value}")

                # Add description for selected item
                if i == self.selected_index:
                    desc = self._get_variable_description(key)
                    if desc:
                        output.append(f"     ⤷ {desc}")

        return output

    def _format_value(self, key: str, value: str) -> str:
        """Format value for display"""
        # Mask sensitive values
        value = self._mask_value(key, value)

        # Empty check
        if not value:
            return "(not set)"

        return f'"{value}"'

    def _mask_value(self, key: str, value: str) -> str:
        """Mask sensitive values"""
        if "KEY" in key.upper() or "SECRET" in key.upper() or "PASSWORD" in key.upper():
            if value:
                # Show first 4 and last 4 characters
                if len(value) > 8:
                    return value[:4] + ("*" * (len(value) - 8)) + value[-4:]
                else:
                    return "*" * len(value)
        return value

    def _get_variable_description(self, key: str) -> str:
        """Get description for variable"""
        descriptions = {
            "GEMINI_API_KEY": "Google Gemini API key for AI features",
            "UDOS_DATA_DIR": "Custom data directory (overrides default)",
            "UDOS_EXTENSIONS_DIR": "Custom extensions directory",
            "UDOS_LOG_LEVEL": "Logging level: DEBUG, INFO, WARNING, ERROR",
            "UDOS_DEBUG": "Enable debug mode (true/false)",
        }
        return descriptions.get(key, "")

    def _render_footer(self) -> str:
        """Render footer with controls"""
        if self.editing_key:
            controls = ["[ENTER] Save", "[ESC] Cancel"]
        else:
            controls = [
                "↑↓ Navigate",
                "[E]dit",
                "[N]ew Variable",
                "[D]elete",
                "[S]ave All",
                "[ESC] Back",
            ]

        return "  ".join(controls)

    def move_selection(self, delta: int):
        """Move selection up/down"""
        sorted_keys = sorted(self.env_vars.keys())
        if not sorted_keys:
            return

        self.selected_index = (self.selected_index + delta) % len(sorted_keys)

    def start_edit(self):
        """Start editing selected variable"""
        sorted_keys = sorted(self.env_vars.keys())
        if not sorted_keys or self.selected_index >= len(sorted_keys):
            return

        key = sorted_keys[self.selected_index]
        current_value = self.env_vars.get(key, "")

        self.editing_key = key
        self.edit_buffer = current_value

    def update_edit_buffer(self, char: str):
        """Update edit buffer"""
        if self.edit_buffer is None:
            self.edit_buffer = ""

        if char == "\x7f":  # Backspace
            self.edit_buffer = self.edit_buffer[:-1]
        elif char.isprintable():
            self.edit_buffer += char

    def save_edit(self) -> Dict[str, Any]:
        """Save current edit"""
        if not self.editing_key or self.edit_buffer is None:
            return {"success": False, "error": "No edit in progress"}

        key = self.editing_key
        value = self.edit_buffer

        # Validation
        result = self._validate_value(key, value)
        if not result["success"]:
            return result

        # Save to env vars
        self.env_vars[key] = value
        self.modified_keys.add(key)

        # Clear edit state
        self.editing_key = None
        self.edit_buffer = None

        return {"success": True, "key": key}

    def cancel_edit(self):
        """Cancel current edit"""
        self.editing_key = None
        self.edit_buffer = None

    def _validate_value(self, key: str, value: str) -> Dict[str, Any]:
        """Validate environment variable value"""
        # Path validation
        if "DIR" in key.upper() or "PATH" in key.upper():
            if value and not Path(value).exists():
                return {"success": False, "error": f"Path does not exist: {value}"}

        # Log level validation
        if key == "UDOS_LOG_LEVEL":
            valid_levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
            if value.upper() not in valid_levels:
                return {
                    "success": False,
                    "error": f'Invalid log level. Use: {", ".join(valid_levels)}',
                }

        return {"success": True}

    def add_variable(self, key: str, value: str = "") -> Dict[str, Any]:
        """Add a new environment variable"""
        if not key:
            return {"success": False, "error": "Key cannot be empty"}

        if key in self.env_vars:
            return {"success": False, "error": f"Variable already exists: {key}"}

        self.env_vars[key] = value
        self.modified_keys.add(key)

        return {"success": True, "key": key}

    def delete_variable(self) -> Dict[str, Any]:
        """Delete selected variable"""
        sorted_keys = sorted(self.env_vars.keys())
        if not sorted_keys or self.selected_index >= len(sorted_keys):
            return {"success": False, "error": "No variable selected"}

        key = sorted_keys[self.selected_index]
        del self.env_vars[key]
        self.modified_keys.discard(key)

        # Adjust selection
        if self.selected_index >= len(self.env_vars):
            self.selected_index = max(0, len(self.env_vars) - 1)

        return {"success": True, "key": key}

    def save_all(self) -> Dict[str, Any]:
        """Save all variables to .env file"""
        if not self.modified_keys:
            return {"success": True, "saved": 0}

        result = self._save_env()
        if result["success"]:
            saved_count = len(self.modified_keys)
            self.modified_keys.clear()
            return {"success": True, "saved": saved_count}

        return result

    def get_summary(self) -> Dict[str, Any]:
        """Get editor summary"""
        return {
            "total_variables": len(self.env_vars),
            "modified": len(self.modified_keys),
            "editing": self.editing_key is not None,
            "env_file": str(self.env_file),
        }


# Global instance
_environment_editor: Optional[EnvironmentEditor] = None


def get_environment_editor() -> EnvironmentEditor:
    """Get global EnvironmentEditor instance"""
    global _environment_editor
    if _environment_editor is None:
        _environment_editor = EnvironmentEditor()
    return _environment_editor
