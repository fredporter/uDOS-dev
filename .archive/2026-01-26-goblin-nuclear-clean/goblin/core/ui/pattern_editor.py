"""
Groovebox Pattern Editor - TUI (16-Step Sequencer)

Interactive terminal-based pattern editor for creating 808-style drum patterns.
16-step grid with 8 tracks, real-time playback cursor, and velocity editing.

Part of uDOS v1.0.3.0+ - Groovebox Extension

Features:
- 16-step Ã— 8-track drum grid
- Real-time playback cursor
- Velocity editing (1-16 levels)
- Track mute/solo
- Pattern copy/paste
- Preset loading/saving
- BPM control
- Swing adjustment

Keyboard Controls:
  Movement:   â†‘/â†“/â†/â†’ or 8/2/4/6 (numpad)
  Edit:       Space/Enter = toggle step, 0-9 = velocity
  Playback:   P = play/pause, S = stop
  Tracks:     M = mute track, O = solo track
  Pattern:    C = copy pattern, V = paste pattern
  Presets:    L = load preset, N = new pattern
  File:       Ctrl+S = save, Ctrl+O = open
  Exit:       Esc or Q

Track Layout (default):
  1. Kick    (C)
  2. Snare   (D)
  3. Hat C   (A)
  4. Hat O   (B)
  5. Clap    (-)
  6. Tom L   (E)
  7. Tom M   (F)
  8. Tom H   (G)

Version: v1.0.0.0
"""

import sys
import os
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any, Callable
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime
import json
import threading
import time

from dev.goblin.core.services.logging_manager import get_logger

logger = get_logger("ui-pattern-editor")


class TrackType(Enum):
    """Drum track types matching 808."""

    KICK = ("Kick", "C", "â—")
    SNARE = ("Snare", "D", "â—†")
    HAT_CLOSED = ("HatC", "A", "Ã—")
    HAT_OPEN = ("HatO", "B", "â—‹")
    CLAP = ("Clap", "-", "â—‡")
    TOM_LOW = ("TomL", "E", "â–¼")
    TOM_MID = ("TomM", "F", "â–½")
    TOM_HIGH = ("TomH", "G", "â–³")

    @property
    def display_name(self) -> str:
        return self.value[0]

    @property
    def mml_note(self) -> str:
        return self.value[1]

    @property
    def step_char(self) -> str:
        return self.value[2]


@dataclass
class Step:
    """Single step in a track."""

    active: bool = False
    velocity: int = 12  # 0-15 (matches MML volume)
    accent: bool = False

    def toggle(self):
        """Toggle step on/off."""
        self.active = not self.active

    def to_char(self) -> str:
        """Get display character based on velocity."""
        if not self.active:
            return "Â·"
        if self.velocity >= 14:
            return "â–ˆ"
        if self.velocity >= 10:
            return "â–“"
        if self.velocity >= 6:
            return "â–’"
        return "â–‘"


@dataclass
class Track:
    """Single drum track with 16 steps."""

    track_type: TrackType
    steps: List[Step] = field(default_factory=lambda: [Step() for _ in range(16)])
    muted: bool = False
    solo: bool = False
    volume: int = 12  # Track volume 0-15

    def toggle_step(self, step_index: int):
        """Toggle step at index."""
        if 0 <= step_index < len(self.steps):
            self.steps[step_index].toggle()

    def clear(self):
        """Clear all steps."""
        for step in self.steps:
            step.active = False

    def to_mml(self) -> str:
        """Convert track to MML notation."""
        mml_parts = []
        note = self.track_type.mml_note.lower()

        for step in self.steps:
            if step.active:
                vol = f"v{step.velocity}" if step.velocity != 12 else ""
                mml_parts.append(f"{vol}{note}16")
            else:
                mml_parts.append("r16")

        return " ".join(mml_parts)


@dataclass
class PatternData:
    """Complete pattern with all tracks."""

    name: str = "Untitled"
    tempo: int = 120
    swing: float = 0.0  # 0.0 - 1.0
    tracks: List[Track] = field(default_factory=list)
    bars: int = 1  # Number of 16-step bars

    def __post_init__(self):
        if not self.tracks:
            self.tracks = [Track(tt) for tt in TrackType]

    def to_mml(self) -> str:
        """Convert entire pattern to MML."""
        lines = [
            f"; Pattern: {self.name}",
            f"; Generated by uDOS Groovebox",
            f"t{self.tempo} l16 o4",
            "",
        ]

        for track in self.tracks:
            if not track.muted:
                lines.append(f"; {track.track_type.display_name}")
                lines.append(track.to_mml())
                lines.append("")

        return "\n".join(lines)

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "name": self.name,
            "tempo": self.tempo,
            "swing": self.swing,
            "bars": self.bars,
            "tracks": [
                {
                    "type": track.track_type.name,
                    "muted": track.muted,
                    "solo": track.solo,
                    "volume": track.volume,
                    "steps": [
                        {"active": s.active, "velocity": s.velocity, "accent": s.accent}
                        for s in track.steps
                    ],
                }
                for track in self.tracks
            ],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PatternData":
        """Deserialize from dictionary."""
        pattern = cls(
            name=data.get("name", "Untitled"),
            tempo=data.get("tempo", 120),
            swing=data.get("swing", 0.0),
            bars=data.get("bars", 1),
        )

        if "tracks" in data:
            pattern.tracks = []
            for track_data in data["tracks"]:
                track_type = TrackType[track_data["type"]]
                track = Track(
                    track_type=track_type,
                    muted=track_data.get("muted", False),
                    solo=track_data.get("solo", False),
                    volume=track_data.get("volume", 12),
                )
                track.steps = [
                    Step(
                        active=s.get("active", False),
                        velocity=s.get("velocity", 12),
                        accent=s.get("accent", False),
                    )
                    for s in track_data.get("steps", [])
                ]
                # Ensure 16 steps
                while len(track.steps) < 16:
                    track.steps.append(Step())
                pattern.tracks.append(track)

        return pattern


class PatternEditor:
    """
    TUI Pattern Editor for 16-step drum patterns.

    Displays a grid of 8 tracks Ã— 16 steps with cursor navigation,
    playback visualization, and pattern editing.
    """

    # ANSI color codes
    COLORS = {
        "reset": "\033[0m",
        "bold": "\033[1m",
        "dim": "\033[2m",
        "cursor": "\033[7m",  # Inverse
        "playhead": "\033[43m\033[30m",  # Yellow bg
        "active": "\033[32m",  # Green
        "muted": "\033[90m",  # Gray
        "solo": "\033[33m",  # Yellow
        "header": "\033[36m",  # Cyan
        "border": "\033[90m",  # Gray
    }

    def __init__(self, pattern: Optional[PatternData] = None):
        """
        Initialize pattern editor.

        Args:
            pattern: Existing pattern to edit, or None for new
        """
        self.pattern = pattern or PatternData()
        self.cursor_track = 0  # Current track (0-7)
        self.cursor_step = 0  # Current step (0-15)
        self.is_playing = False
        self.playhead = 0  # Current playback position
        self.modified = False

        # Callbacks
        self.on_play: Optional[Callable[[PatternData], None]] = None
        self.on_stop: Optional[Callable[[], None]] = None
        self.on_save: Optional[Callable[[PatternData], None]] = None

        # Clipboard
        self._clipboard: Optional[PatternData] = None

        logger.info(f"[LOCAL] PatternEditor initialized: {self.pattern.name}")

    def render(self, width: int = 80) -> List[str]:
        """
        Render the pattern editor grid.

        Args:
            width: Terminal width

        Returns:
            List of lines to display
        """
        lines = []
        c = self.COLORS

        # Header
        lines.append(f"{c['header']}â”Œ{'â”€' * 50}â”{c['reset']}")
        status = "â–¶ PLAYING" if self.is_playing else "â–  STOPPED"
        lines.append(
            f"{c['header']}â”‚{c['reset']} {c['bold']}ðŸŽ¹ {self.pattern.name}{c['reset']}"
            f"  {status}  BPM:{self.pattern.tempo}  "
            f"{c['header']}â”‚{c['reset']}"
        )
        lines.append(f"{c['header']}â”œ{'â”€' * 50}â”¤{c['reset']}")

        # Step numbers header
        step_header = "      â”‚"
        for i in range(16):
            if i == self.playhead and self.is_playing:
                step_header += f"{c['playhead']}{i+1:2}{c['reset']}"
            elif i % 4 == 0:
                step_header += f"{c['bold']}{i+1:2}{c['reset']}"
            else:
                step_header += f"{c['dim']}{i+1:2}{c['reset']}"
        step_header += "â”‚"
        lines.append(step_header)

        # Separator
        lines.append(f"â”€â”€â”€â”€â”€â”€â”¼{'â”€â”€' * 16}â”¤")

        # Tracks
        for t_idx, track in enumerate(self.pattern.tracks):
            line = self._render_track(track, t_idx)
            lines.append(line)

        # Footer separator
        lines.append(f"â”€â”€â”€â”€â”€â”€â”´{'â”€â”€' * 16}â”˜")

        # Controls help
        lines.append("")
        lines.append(
            f"{c['dim']}â†‘â†“â†â†’:Move  Space:Toggle  P:Play  S:Stop  M:Mute  +/-:BPM  Q:Exit{c['reset']}"
        )

        return lines

    def _render_track(self, track: Track, track_index: int) -> str:
        """Render a single track row."""
        c = self.COLORS

        # Track name with status indicators
        name = track.track_type.display_name[:5].ljust(5)
        if track.muted:
            name = f"{c['muted']}M{name}{c['reset']}"
        elif track.solo:
            name = f"{c['solo']}S{name}{c['reset']}"
        else:
            name = f" {name}"

        line = f"{name}â”‚"

        # Steps
        for s_idx, step in enumerate(track.steps):
            is_cursor = track_index == self.cursor_track and s_idx == self.cursor_step
            is_playhead = s_idx == self.playhead and self.is_playing

            # Determine character
            if step.active:
                char = step.to_char()
                if track.muted:
                    char_colored = f"{c['muted']}{char}{c['reset']}"
                else:
                    char_colored = f"{c['active']}{char}{c['reset']}"
            else:
                char = "Â·"
                char_colored = f"{c['dim']}{char}{c['reset']}"

            # Apply cursor/playhead highlighting
            if is_cursor and is_playhead:
                cell = f"{c['cursor']}{c['playhead']}{char} {c['reset']}"
            elif is_cursor:
                cell = f"{c['cursor']}{char} {c['reset']}"
            elif is_playhead:
                cell = f"{c['playhead']}{char} {c['reset']}"
            else:
                cell = f"{char_colored} "

            line += cell

        line += "â”‚"
        return line

    def handle_key(self, key: str) -> Optional[str]:
        """
        Handle keyboard input.

        Args:
            key: Key pressed

        Returns:
            Command result or None
        """
        # Navigation
        if key in ("up", "8", "k"):
            self.cursor_track = max(0, self.cursor_track - 1)
        elif key in ("down", "2", "j"):
            self.cursor_track = min(len(self.pattern.tracks) - 1, self.cursor_track + 1)
        elif key in ("left", "4", "h"):
            self.cursor_step = max(0, self.cursor_step - 1)
        elif key in ("right", "6", "l"):
            self.cursor_step = min(15, self.cursor_step + 1)

        # Step editing
        elif key in ("space", "enter", "5"):
            track = self.pattern.tracks[self.cursor_track]
            track.toggle_step(self.cursor_step)
            self.modified = True

        # Velocity (0-9 sets velocity level)
        elif key.isdigit():
            vel = int(key)
            if vel == 0:
                vel = 10  # 0 key = velocity 10
            track = self.pattern.tracks[self.cursor_track]
            step = track.steps[self.cursor_step]
            step.velocity = vel + 5  # Map 1-10 to 6-15
            step.active = True
            self.modified = True

        # Playback
        elif key.lower() == "p":
            self.is_playing = not self.is_playing
            if self.is_playing and self.on_play:
                self.on_play(self.pattern)
            elif not self.is_playing and self.on_stop:
                self.on_stop()

        elif key.lower() == "s":
            self.is_playing = False
            self.playhead = 0
            if self.on_stop:
                self.on_stop()

        # Track controls
        elif key.lower() == "m":
            track = self.pattern.tracks[self.cursor_track]
            track.muted = not track.muted
            if track.muted:
                track.solo = False

        elif key.lower() == "o":
            track = self.pattern.tracks[self.cursor_track]
            track.solo = not track.solo
            if track.solo:
                track.muted = False
                # Unmute this, mute others
                for t in self.pattern.tracks:
                    if t != track:
                        t.solo = False

        # BPM
        elif key == "+":
            self.pattern.tempo = min(300, self.pattern.tempo + 5)
            self.modified = True
        elif key == "-":
            self.pattern.tempo = max(40, self.pattern.tempo - 5)
            self.modified = True

        # Clear track
        elif key.lower() == "c" and not self._has_shift():
            track = self.pattern.tracks[self.cursor_track]
            track.clear()
            self.modified = True

        # Pattern operations
        elif key.lower() == "n":
            self.pattern = PatternData()
            self.modified = False
            return "New pattern created"

        # Exit
        elif key in ("q", "escape"):
            return "EXIT"

        return None

    def _has_shift(self) -> bool:
        """Check if shift is held (stub for future)."""
        return False

    def advance_playhead(self):
        """Advance playhead by one step."""
        self.playhead = (self.playhead + 1) % 16

    def get_mml(self) -> str:
        """Get MML representation of pattern."""
        return self.pattern.to_mml()

    def save(self, filepath: Path) -> bool:
        """Save pattern to JSON file."""
        try:
            data = self.pattern.to_dict()
            filepath.parent.mkdir(parents=True, exist_ok=True)
            filepath.write_text(json.dumps(data, indent=2))
            self.modified = False
            logger.info(f"[LOCAL] Pattern saved: {filepath}")
            return True
        except Exception as e:
            logger.error(f"[LOCAL] Save failed: {e}")
            return False

    def load(self, filepath: Path) -> bool:
        """Load pattern from JSON file."""
        try:
            data = json.loads(filepath.read_text())
            self.pattern = PatternData.from_dict(data)
            self.modified = False
            logger.info(f"[LOCAL] Pattern loaded: {filepath}")
            return True
        except Exception as e:
            logger.error(f"[LOCAL] Load failed: {e}")
            return False


def create_pattern_viewport(pattern: Optional[PatternData] = None) -> PatternEditor:
    """
    Create a pattern editor viewport.

    Args:
        pattern: Existing pattern or None for new

    Returns:
        PatternEditor instance
    """
    return PatternEditor(pattern)


# Preset patterns for quick start
PRESET_PATTERNS = {
    "four_on_floor": {
        "name": "Four on the Floor",
        "tempo": 120,
        "tracks": [
            {"type": "KICK", "steps": [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0]},
            {
                "type": "SNARE",
                "steps": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
            },
            {
                "type": "HAT_CLOSED",
                "steps": [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
            },
        ],
    },
    "breakbeat": {
        "name": "Breakbeat",
        "tempo": 135,
        "tracks": [
            {"type": "KICK", "steps": [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]},
            {
                "type": "SNARE",
                "steps": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            },
            {
                "type": "HAT_CLOSED",
                "steps": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            },
        ],
    },
    "hip_hop": {
        "name": "Hip Hop",
        "tempo": 90,
        "tracks": [
            {"type": "KICK", "steps": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]},
            {
                "type": "SNARE",
                "steps": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
            },
            {
                "type": "HAT_CLOSED",
                "steps": [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
            },
        ],
    },
}


def load_preset(name: str) -> Optional[PatternData]:
    """Load a preset pattern by name."""
    if name not in PRESET_PATTERNS:
        return None

    preset = PRESET_PATTERNS[name]
    pattern = PatternData(name=preset["name"], tempo=preset["tempo"])

    for track_data in preset.get("tracks", []):
        track_type = TrackType[track_data["type"]]
        # Find the track in pattern
        for track in pattern.tracks:
            if track.track_type == track_type:
                for i, active in enumerate(track_data.get("steps", [])):
                    if i < len(track.steps):
                        track.steps[i].active = bool(active)
                break

    return pattern


if __name__ == "__main__":
    # Test rendering
    editor = PatternEditor()
    editor.pattern.name = "Test Pattern"
    editor.pattern.tracks[0].steps[0].active = True
    editor.pattern.tracks[0].steps[4].active = True
    editor.pattern.tracks[0].steps[8].active = True
    editor.pattern.tracks[0].steps[12].active = True

    for line in editor.render():
        print(line)
